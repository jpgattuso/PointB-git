---
title: "Time series and comparison for Point B/B+ and EOL data"
author: "Samir Alliouane, Frederic Gazeau, Steeve Comeau, Jean-Pierre Gattuso, CNRS-UPMC."
date: '`r format(Sys.Date(), "%d %B %Y")`'
output:
  rmarkdown::html_document:
    code_folding: hide
    fig_caption: yes
    toc: yes
    toc_float: yes
---


```{r setup, include=FALSE}
rm(list = ls())
require(tidyverse)
require(data.table)
require(readxl)
require(pander)
require(seacarb)
library(cowplot)
library(scales)
library(RColorBrewer)
library(gridExtra)
library(reshape2)
library(xtable)
library(zoo)
library(lubridate)
library(nlme)
library(lmtest)
library(readr)
library(dygraphs)
library(grid)
library(viridis)
library(animation)
library(directlabels)
library(tibble)
library(xts)
require("knitr")
library(broom)
library("lmodel2") # modele II regression
#library(plyr)
library(pander)


#define who is the user and define path
if (Sys.getenv("LOGNAME") == "gattuso") {
  path = "../../pCloud\ Sync/Documents/experiments/exp153_carbonates_point_B/"
  path_sami = "../../pCloud\ Sync/Documents/experiments/exp176_sami/vlfr_ph_data/3_out_ph_sami_seafet/out_deployment/"
}
if (Sys.getenv("LOGNAME") == "samir") {
  path = "../../pCloud Sync/exp153_carbonates_point_B/"
  path_sami = "../../pCloud\ Sync/exp176_sami/vlfr_ph_data/3_out_ph_sami_seafet/out_deployment/"
  path_par ="../../pCloud Sync/Light_Series_Odyssey/par_data/Villefranche/"
}

Sys.setenv(TZ='UTC')

#################### Regression function 

######## To add regression line on ggplots
# use as annotate(aes(x = 25, y = 300, label = lm_eqn(lm(y ~ x, df))), parse = TRUE)
# http://stackoverflow.com/questions/7549694/ggplot2-adding-regression-line-equation-and-r2-on-graph
lm_eqn = function(m) {
  l <- list(a = format(coef(m)[1], digits = 2),
      b = format(abs(coef(m)[2]), digits = 2),
      r2 = format(summary(m)$r.squared, digits = 3));
  if (coef(m)[2] >= 0)  {
    eq <- substitute(italic(y) == a + b %.% italic(x)*","~~italic(r)^2~"="~r2,l)
  } else {
    eq <- substitute(italic(y) == a - b %.% italic(x)*","~~italic(r)^2~"="~r2,l)    
  }
  as.character(as.expression(eq));                 
}

######## function to make regression plot with model I equation in title
ggreg <- function (fit, point_size=2) {
  ggplot(fit$model, aes_string(x = names(fit$model)[2],
                               y = names(fit$model)[1])) +
    geom_point(size = point_size, col = "blue") +
    stat_smooth(method = "lm", col = "black") +
    labs(title = paste(title, "\nAdj R2 = ",signif(summary(fit)$adj.r.squared, 5),
                       "; Intercept =",signif(fit$coef[[1]],5 ),
                       "; Slope =",signif(fit$coef[[2]], 5),
                       "; P =",signif(summary(fit)$coef[2,4], 5))) +
    theme(plot.title = element_text(size=7))
}

########### Regression function 
####
# function regression plot with model II equation (MA) in title
## Dans labs ajout de la variable TITRE pour mettre titre avant chaque graphe
ggreg2 <- function (fit, xdata, ydata) { # x and y are the names of the variables
  fit_data <- data.frame(fit$x, fit$y)
  colnames(fit_data) = c(xdata, ydata)
reg <- fit$regression.results[2,] #one selects MA only
intercept <- reg$Intercept
slope <- reg$Slope
  ggplot(data = fit_data, aes_string(x = xdata, y = ydata)) + 
  geom_point(size = 3, col = "blue") +
  geom_abline(aes(intercept = fit$regression.results[2,2], slope = fit$regression.results[2,3]),
              colour = "blue")  + 
  labs(title = paste(titre,"\n Adj R2 = ", signif(fit$rsquare, 3),
                     "; Intercept =", signif(intercept, 3),
                     "; Slope =", signif(slope, 3),
                     "; P =", signif(fit$P.param, 3),
                     "; n =", (fit$n)))
}

mytheme <- theme_bw() +
  theme(axis.text.x=element_text(size=16, color="black"),
        axis.title.x=element_text(face="bold", size=16),
        axis.text.y=element_text(size=16, color="black"),
        axis.title.y=element_text(face="bold", size=16),
        plot.title = element_text(face="bold", size=14)
)
```

# **PAR EOL** {.tabset .tabset-pills}

## **Deployment**

```{r PAR 10m, warning = FALSE}
# YOU MUST add manually the "deployement"_calibrated" information in the end of the title file
file_list_10m <- list.files(path  = paste0(path_par, "EOL_10m"), pattern = "*_calibrated.CSV")

if (length(file_list_10m) == 0) {stop()} # script does not run if there is no data file to read
ii <- 0
for (file in file_list_10m){
  ii <- ii + 1
  tmp <- read.table(paste0(path_par, "EOL_10m/", file, sep = ""), header = F, dec = ".", as.is = TRUE, sep = ";", skip = 11, fill = TRUE)

  if (ii == 1) {par_10m <- tmp} else {par_10m <- rbind(par_10m, tmp)}
  #remove unused columns
  par_10m <- par_10m %>% 
    dplyr::select(-c("V1", "V6")) %>% 
  tidyr::unite(col="datetime", V2, V3, sep = " " )
}

colnames(par_10m)  <- c("datetime", "raw_value_10", "int_light_10")
par_10m$datetime <- dmy_hms(par_10m$date)
```

```{r PAR 20m, warning = FALSE}
 file_list_20m <- list.files(path  = paste0(path_par, "EOL_20m"), pattern = "*_calibrated.CSV")

if (length(file_list_20m) == 0) {stop()} # script does not run if there is no data file to read
ii <- 0
for (file in file_list_20m){
  ii <- ii + 1
  tmp <- read.table(paste0(path_par, "EOL_20m/", file, sep = ""), header = F, dec = ".", as.is = TRUE, sep = ";", skip = 11, fill = TRUE)

  if (ii == 1) {par_20m <- tmp} else {par_20m <- rbind(par_20m, tmp)}
  #remove unused columns
  par_20m <- par_20m %>% 
    dplyr::select(-c("V1", "V6")) %>% 
  tidyr::unite(col="datetime", V2, V3, sep = " " )
}

colnames(par_20m)  <- c("datetime", "raw_value_20", "int_light_20")
par_20m$datetime <- dmy_hms(par_20m$date)
```

```{r PAR 30m, warning = FALSE}
 file_list_30m <- list.files(path  = paste0(path_par, "EOL_30m"), pattern = "*_calibrated.CSV")

if (length(file_list_30m) == 0) {stop()} # script does not run if there is no data file to read
ii <- 0
for (file in file_list_30m){
  ii <- ii + 1
  tmp <- read.table(paste0(path_par, "EOL_30m/", file, sep = ""), header = F, dec = ".", as.is = TRUE, sep = ";", skip = 11, fill = TRUE)

  if (ii == 1) {par_30m <- tmp} else {par_30m <- rbind(par_30m, tmp)}
  #remove unused columns
  par_30m <- par_30m %>% 
    dplyr::select(-c("V1", "V6")) %>% 
  tidyr::unite(col="datetime", V2, V3, sep = " " )
}

colnames(par_30m)  <- c("datetime", "raw_value_30", "int_light_30")
par_30m$datetime <- dmy_hms(par_30m$date)

```

```{r PAR plot, warning = FALSE, out.width='100%'}
par_all <- left_join(par_10m,par_20m,by="datetime")
par_all <- left_join(par_all,par_30m,by="datetime")
par_all <- par_all[-1, ]

par_xts <- dplyr::select(par_all, datetime, int_light_10, int_light_20, int_light_30)
par_xts <- as.xts(par_xts, order.by=par_xts$datetime)

dygraph(par_xts, ylab = "") %>%
  dySeries("int_light_10", drawPoints = TRUE, pointSize=3, color="deepskyblue",label = "PAR 10m")%>%
  dySeries("int_light_20", drawPoints = TRUE, pointSize=3, color = "dodgerblue", label = "PAR 20m") %>%
  dySeries("int_light_30", drawPoints = TRUE, pointSize=3, color= "dodgerblue4", label = "PAR 30m") %>%
 # dyLegend(show = "always", width = 600)%>%
dyOptions(
    drawGrid = TRUE,
    drawPoints = TRUE,
    useDataTimezone = TRUE)%>%
  dyRangeSelector(height = 30)
```

## **Logs - Informations**

```{r kable log par}
## Open the first spreadsheet of the "PlanktonChange_data" googlesheet (need to go to File/Publish to the web and publish as csv)

url_par_log <- "https://docs.google.com/spreadsheets/d/e/2PACX-1vRKsEOg29pe4RdV8W5Cz8lMFhm-lllLy66Z7t6qRjw3ueF1sHVcSbmVgozttv3LGQ/pub?gid=485625929&single=true&output=csv"
par_log <- read.csv(url(url_par_log), header=T, stringsAsFactors = FALSE)
#replade dots with spaces in column names.
kable(par_log, col.names = gsub("[.]", " ", names(par_log)), align ="c", caption="**piSAMI logs (metadata)**")
```

# **seafet pH**  {.tabset .tabset-pills}

## **Deployment**

```{r seafet pH, echo=FALSE, warning = FALSE, message = FALSE, out.width='100%'}
continuous_discrete <- read.table(paste0(path, "data/continuous_discrete.csv"), header=TRUE, sep=",", dec=".", as.is=TRUE)

continuous_discrete$datetime <- ymd_hms(continuous_discrete$date)
#round time into nearest hour
continuous_discrete$datetime <-round_date(continuous_discrete$datetime,unit = "hour" )

## PLOT
sf_xts <- dplyr::select(continuous_discrete, datetime, pHT_sfint, T_seaF, pHspec_Tptb, pHcalc_ptB)
sf_xts <- as.xts(sf_xts, order.by=sf_xts$datetime)

dygraph(sf_xts, ylab = "") %>%
  dySeries("pHT_sfint", drawPoints = TRUE, pointSize=2, label = "pH corrected")%>%
  dySeries("pHspec_Tptb", drawPoints = TRUE, pointSize=3, color = "red", label = "pH spectro (T ptB)") %>%
  dySeries("pHcalc_ptB", drawPoints = TRUE, pointSize=3, label = "pH calc (T ptB)") %>%
 dySeries(axis = "y2","T_seaF", drawPoints = TRUE, pointSize=2, label = "T_seaF") %>%
 # dyLegend(show = "always", width = 600)%>%
dyOptions(
    drawGrid = TRUE,
    drawPoints = TRUE,
    useDataTimezone = TRUE)%>%
  dyRangeSelector(height = 30)
```

# **SAMI pH**  {.tabset .tabset-pills}

## **Deployment**

```{r sami pH, echo=FALSE, warning = FALSE, message = FALSE, out.width='100%'}
# read deployment file
file_list <- list.files(path  = path_sami, pattern = "Raw_SAMI.*.txt")

if (length(file_list) == 0) {stop()} # script does not run if there is no data file to read
ii <- 0
for (file in file_list){
  ii <- ii + 1
  tmp <- read.table(paste(path_sami, file, sep = ""), header = F, dec = ".", as.is = TRUE, sep = "\t", skip = 5, fill = TRUE)
# YOU MUST add manually the deployement number in the title file
# The following take last digit in the title file
  tmp$deployment_sami <- as.numeric(substr(str_extract(file, "-[0-9][0-9]\\."),2,3))
  colnames(tmp)  <- c("datetime","ph_sami", "ph_error_sami", "temp_int_sami", "temp_ext_sami","flag_sami", "deployment_sami")
  tmp$datetime <- mdy_hms(tmp$datetime, tz="UTC")
  if (ii == 1) {sami <- tmp} 
  else {sami <- rbind(sami, tmp)}
}

# # put the file in the processed file
# if (length(file_list) > 0) {
#   for (file in file_list){
#     # move new zip files from PointB to processed PointB
#     system(paste0("mv ../../pCloud Sync/piSami-pH/sami_data/sami_processed/Salinity_corrected/PointB/", file, " ../../pCloud Sync/piSami-pH/sami_data/sami_processed/Salinity_corrected/PointB/PointB_processed"))
#   }
# }

# Convert datetime
#sami$datetime <- mdy_hms(sami$datetime, tz="UTC")

# supprimer les données erronées
sami <- sami %>%
  dplyr::filter(flag_sami == 0 & ph_sami >= 7.8 & ph_sami <= 8.2)

save(sami, file = paste0(path, "data/sami/sami_all_eol.csv"))

## Add event periodes manually
## Events
sami_events <- c("2019-12-16 11:00:00", "2020-02-25 16:00:00","2020-06-17 08:00:00","2020-06-19 10:00:00","2020-07-15 10:00:00","2020-07-17 18:00:00", "2020-08-10 00:00:00", "2020-12-10 13:00:00","2020-12-17 09:00:00","2021-02-17 09:00:00")

## PLOT
sami_xts <- dplyr::select(sami, datetime, ph_sami, temp_int_sami, temp_ext_sami)
sami_xts <- as.xts(sami_xts, order.by=sami_xts$datetime)
dygraph(sami_xts, ylab = "") %>%
  dySeries("ph_sami", drawPoints = TRUE, pointSize=2, label = "ph_sami")%>%
  dySeries(axis = "y2","temp_int_sami", drawPoints = TRUE, pointSize=2, label = "temp_int_sami") %>%
  dySeries(axis = "y2", "temp_ext_sami", drawPoints = TRUE, pointSize=2, label = "temp_ext_sami") %>%
   dyEvent(as.POSIXct("2020-07-16 12:00:00", tz="GMT"), "reagent bag changed", labelLoc = "bottom", color="red") %>%
   dyEvent(as.POSIXct("2020-07-16 11:30:00", tz="GMT"), "end of TRIS calib", labelLoc = "top", color="red") %>%
   dyEvent(as.POSIXct("2019-12-05 11:00:00", tz="GMT"), "end of TRIS calib", labelLoc = "bottom", color="red") %>%
  dyShading(from = sami_events[1], to = sami_events[2], color = "#CCCCCC") %>%
  dyShading(from = sami_events[2], to = sami_events[3], color = "#E0E0E0") %>%
   dyShading(from = sami_events[4], to = sami_events[5], color = "#CCCCCC") %>%
    dyShading(from = sami_events[5], to = sami_events[6], color = "#E0E0E0") %>%
    dyShading(from = sami_events[6], to = sami_events[7], color = "#CCCCCC") %>%
    dyShading(from = sami_events[8], to = sami_events[9], color = "#E0E0E0") %>%
    dyShading(from = sami_events[9], to = sami_events[10], color = "#CCCCCC") %>%
 # dyLegend(show = "always", width = 600)%>%
  #dyAxis("y",valueRange = c(-0.1, 0.11))%>%
dyOptions(
    drawGrid = TRUE,
    drawPoints = TRUE,
    useDataTimezone = TRUE)%>%
  dyRangeSelector(height = 30)
```

## **Logs - Informations**

```{r kable log sami}
## Open the first spreadsheet of the "PlanktonChange_data" googlesheet (need to go to File/Publish to the web and publish as csv)

url_sami_log <- "https://docs.google.com/spreadsheets/d/e/2PACX-1vSmth08Q-Tw1RFznKeStSMJkKeFgYZac9WIR3ETLYWkznouAD6A-1n2uza1YgotXQ/pub?gid=798409504&single=true&output=csv"
sami_log <- read.csv(url(url_sami_log), header=T, stringsAsFactors = FALSE)
#replade dots with spaces in column names.
kable(sami_log, col.names = gsub("[.]", " ", names(sami_log)), align ="c", caption="**piSAMI logs (metadata)**")
```
 
## **Sunburst - TRIS info**
 
 Here are gathered important emails from Sunburst concerning SAMI handling (reggie@sunburstsensors.com):

  +   **29/10/2019 at 18:53**

**The blank signals are stable, indicating no air bubbles in the lines. Absorbances show a good curve in the expected range, indicating that the pump and valve are working properly.**
pH measurements are extremely temperature sensitive.  In order to get best results, the following procedures must be followed:
- the PiSAMI must be completely submersed in the sample and equilibrated to the sample temperature
- if the sample is in a bottle, the bottle must be submersed in the same water as the PiSAMI
- when comparing discrete pH to PiSAMI pH, the measurements must be either made at the EXACT same temperature, or corrected to the same temperature (generally seawater pH changes by -0.015 per degree C)
- Theoretical Tris pH must be calculated at the PiSAMI Internal Temperature, as this is the temperature at which the PiSAMI measured pH
- when processing Tris data with QC_PH, choose "Tris validation."  This actually calculates pH a bit differently (**taking an average of several measurements; whereas seawater pH is calculated by extrapolating several pH measurements vs indicator concentration**). 
I suspect that some of the offsets you are seeing between theoretical pH or discrete pH and PiSAMI pH have to do with temperature.  For example, see the 161019 file.  If you measured discrete pH at 25C, it would differ from the SAMI pH by ~0.04-0.05 pH.  The Tris file that you sent me only has 2 samples in it, so I cannot see all of your data.  However, these two samples come out to  a difference between theoretical pH (at SAMI internal temperature) and measured pH of 0.0046 and 0.0056 (see the Diff column).  However, the pH does differ substantially from the pH of Tris at 22.118C.
I believe that the apparently poor precision you are seeing in some of the seawater analysis also is due to temperature,  If you have a flow-through system, the temperature of the water seems to not be stable.  The instability in pH mimics the changes in water temperature, indicating that the pH of the water is also changing (see the 181019 file).

## **Sunburst - Temperature Int/Ext**

+   **29/10/2019 at 20:10**

- **<span style="color:red"> Seawater pH </span> is calculated at TempInt, then corrected to <span style="color:red"> TempExt </span> (using -0.015 pH/C)**; in this case you would compare pH of discrete samples at TempExt.
- **<span style="color:red"> Tris pH </span> is calculated at <span style="color:red"> TempInt </span>**; in this case you would compare theoretical pH of Tris at TempInt.

## **Sunburst - Tris and seawater calculations **
 
 + **16/12/2019 à 20:40**
 
 - **When Tris pH is calculated, the software takes an average of several measurements, whereas when seawater pH is calculated the software will extrapolate to a pH without indicator.**  We do this because seawater pH is perturbed by the indicator, whereas Tris pH is not.  

With the PiSAMI there is a thermistor inside the instrument and one on the outside.  pH is calculated at the internal temperature.  
  - **For seawater, the pH is then corrected to the external temperature. ** 
  - **For Tris the internal temperature is used to calculate the measured and theoretical pH and the difference.**  You can see that when Tris pH is calculated from the QC program, the standard deviation is much smaller, although it seems that the average error is not much different (0.0091 +/-0.0019).  I also did a rough correction of Tris pH to the external pH, and the offset does not change.

**<span style="color:red"> You could consider applying this offset to your field data, given that it is the same, or similar, both pre- and post-deployment. </span>**

## **Sunburst - TRIS calculation**

+ **17/01/2020 à 22:36**

Samir: 

- Based on your comments from your last email (bellow), we have recalculated the Tris values and got the same results than you.
- Concerning the TRIS, we do use TRIS provided by Dickson's lab. We then assume that there is no "tris offset" nor "temp offset" to add when we are using "tris validation" window: We asked Dickson's lab for TRIS offset information and they just gave to us a template to calculate TRIS according to T and S. In this template (see attached ) you can see in cell B7 a Delta pH to fill: "Adjustment if buffer is not identical to that of Del Valls & Dickson (1998)"
 **As a result without any tris/temp offset, we ended up to the same results than you (we also removed the first line).**
 We therefore found an offset of +0.0091 pH unit between the theoretical tris value and the one measured by the SAMI. Should we add this offset to each SAMI measurement?

(@) When should tris validation be done again? What is the maximum period of time that we can deploy the SAMI without tris validation? Example: each 2 months, 3 months? <span style="color:blue">Tris validation should need to be done when you replace a reagent bag, or after 1 year.  However, during deployment if the flow path becomes fouled you will see a lot more noise in the pH measurement.  This will mean that it is time to clean the PiSAMI or send it to us for refurbishment.</span>

(@) In the manual, the accuracy should be better or equal to +/- 0.006 (maximum accuracy acceptable with a tris validation). This is not the case here. We have 0.0091. What do you think is the cause for this problem?  <span style="color:blue">I am not sure what is going on.  I suspect a slight difference between your method and ours, or between Dickson Tris and ours, or both.  You could apply the offset to your samples.  If you do that, make sure that you validate the same way and apply the offset every time you deploy.</span>

(@) Please, could you further explain: "the problem that occurs when we set the salinity before deployment". When we set the salinity to 38, this is not recorded and we found the default salinity of 35 when we download the data.  <span style="color:blue">This is a little confusing, but you do not need to set the salinity before deployment.  You do need to set the salinity before processing the data.  The number that salinity is set to at the time of processing will be used.</span>

## **Sunburst - Copper mesh clogging**

+ **November 2020 from Nuria**

About the Copper Mesh we have to screw for deployment:

Do you feel like water is not getting through the mesh? 

The mesh could be removed, if you prefer. The filter might need more frequent replacement if you used it this way though.
It is possible that when the mesh corrodes significantly from the seawater that it becomes less porous. I'm not confident on which option is the best. If you are deploying at a sight that is cold and low fouling/low dissolved solids, you could go without the entire filter. Since every site is different, it is difficult to predict the outcome.

# **EOL raw data** {.tabset .tabset-pills}

Temperature (in blue, °C), salinity (in purple, PSU) and oxygen (in green, ml/l) data from the EOL ctd.

```{r EOL data, echo=FALSE, warning = FALSE, message = FALSE, out.width='100%'}
# url <- "http://obs-vlfr.fr/data/files/~eol/somlit/"
# files <- httr::GET(url) %>%
#   httr::content(as="parsed") %>%
#   # get all links containing villefranche-eol
#   xml2::xml_find_all("//a[contains(.,'villefranche-eol')]") %>%
#   # in a flat vector
#   xml2::as_list() %>%
#   unlist()
# urls <- str_c(url, files)
# eol <- purrr::map_dfr(urls, read_csv, comment="#", col_types=cols(Date="c", Heure="c"))
# eol <- dplyr::mutate(eol, datetime=str_c(Date, " ", Heure) %>% parse_datetime(format="%Y%m%d %H%M%S"))
# 
# # replace outliers O2 data by NA
# eol <- dplyr::mutate(eol, O2 = case_when(O2 >= 999 ~ NA_real_ ,
#                                        TRUE ~ O2))
# 
# #round time to nearest hour
# eol$datetime_round <-round_date(eol$datetime,unit = "hour" )
# 
# ## PLOT 1 = all eol data S T
# eol_xts <- dplyr::select(eol, datetime, S, T, O2)
# eol_xts <- as.xts(eol_xts, order.by=eol_xts$datetime)
# 
# dygraph(eol_xts, main = "EOL S T data: all depths, raw time", ylab = "") %>%
#   dySeries("T", drawPoints = TRUE, pointSize=2, label = "Temp")%>%
#   dySeries("O2", drawPoints = TRUE, pointSize=2, label = "oxy")%>%
#   dySeries(axis = "y2","S", drawPoints = TRUE, pointSize=2, label = "Sal") %>%
#  # dyLegend(show = "always", width = 600)%>%
#   #dyAxis("y",valueRange = c(-0.1, 0.11))%>%
# dyOptions(
#     drawGrid = TRUE,
#     drawPoints = TRUE,
#     useDataTimezone = TRUE)%>%
#   dyRangeSelector(height = 30)
# 
# #make the mean with same date and rounded time + filter only surface data 1 to 3 m.
# mean_eol <- eol %>%
#   group_by( P, datetime_round) %>%
#   dplyr::summarise(
#             mean_sal_eol = mean(S, na.rm=TRUE),
#             mean_temp_eol = mean(T, na.rm=TRUE),
#             mean_oxy_eol = mean(O2, na.rm=TRUE)) %>%
#   dplyr::rename(datetime = datetime_round) %>%
#   dplyr::filter(P >=1 & P <= 3)
# 
# 
# ## PLOT 2 = 0 to 2 m + rounded time to hour
# eol_xts <- dplyr::select(mean_eol, datetime_round, mean_sal_eol, mean_temp_eol, mean_oxy_eol)
# eol_xts <- as.xts(eol_xts, order.by=eol_xts$datetime_round)
# 
# dygraph(eol_xts,  main = "EOL data: 0 to 3 m depth , rounded time to nearest hour", ylab = "") %>%
#   dySeries("mean_temp_eol", drawPoints = TRUE, pointSize=2, label = "Temp")%>%
#   dySeries(axis = "y2","mean_sal_eol", drawPoints = TRUE, pointSize=2, label = "Sal") %>%
#     dySeries("mean_oxy_eol", drawPoints = TRUE, pointSize=2, label = "oxy")%>%
#  # dyLegend(show = "always", width = 600)%>%
#   #dyAxis("y",valueRange = c(-0.1, 0.11))%>%
# dyOptions(
#     drawGrid = TRUE,
#     drawPoints = TRUE,
#     useDataTimezone = TRUE)%>%
#   dyRangeSelector(height = 30)
# ### SAVE
# saveRDS(eol, file = paste0(path, "data/eol/eol_data.rds"))
url <- "http://obs-vlfr.fr/data/files/~eol/somlit/"
files <- httr::GET(url) %>%
  httr::content(as="parsed") %>%
  # get all links containing villefranche-eol
  xml2::xml_find_all("//a[contains(.,'villefranche-eol')]") %>%
  # in a flat vector
  xml2::as_list() %>%
  unlist()
urls <- str_c(url, files)
eol <- purrr::map_dfr(urls, read_csv, comment="#", col_types=cols(Date="c", Heure="c"))
#backup eol
eol1 <- eol
eol1 <- dplyr::mutate(eol1, datetime=str_c(Date, " ", Heure) %>% parse_datetime(format="%Y%m%d %H%M%S"))

eol <- dplyr::mutate(eol, datetime=str_c(Date, " ", Heure) %>% parse_datetime(format="%Y%m%d %H%M%S"))

# replace outliers O2 data by NA + remove O2 > 6 units
eol <- dplyr::mutate(eol, O2 = case_when(O2 > 6 ~ NA_real_,
                                         O2 >= 999 ~ NA_real_ ,
                                         TRUE ~ O2
                                        ),
                        Turb = case_when(Turb > 999 ~ NA_real_,
                                         TRUE ~ Turb),
                        Fluo = case_when(Fluo > 999 ~ NA_real_,
                                        TRUE ~ Fluo)
)

eol <- eol%>%
  dplyr::rename(temp_eol = T,
                sal_eol = S,
                oxy_eol = O2)

## PLOT 1 = all eol data S T
eol_xts <- dplyr::select(eol, datetime, temp_eol, sal_eol, oxy_eol)
eol_xts <- as.xts(eol_xts, order.by=eol_xts$datetime)

dygraph(eol_xts, main = "EOL S T data: all depths", ylab = "") %>%
  dySeries("temp_eol", drawPoints = TRUE, pointSize=2, label = "Temp")%>%
  dySeries("oxy_eol", drawPoints = TRUE, pointSize=2, label = "oxy")%>%
  dySeries(axis = "y2","sal_eol", drawPoints = TRUE, pointSize=2, label = "Sal") %>%
  dyAxis(name = "y2", axisLineColor = "purple", axisLabelColor = "purple") %>% 
 # dyLegend(show = "always", width = 600)%>%
  #dyAxis("y",valueRange = c(-0.1, 0.11))%>%
dyOptions(drawGrid = TRUE,
    drawPoints = TRUE,
    useDataTimezone = TRUE)%>%
  dyRangeSelector(height = 30)

### SAVE
saveRDS(eol, file = paste0(path, "data/eol/eol_data.rds"))
```

# **Rade Hydro, SOMLIT (ctd_hydro, Point B / B+)**  {.tabset .tabset-pills}

Time is not included in dataset. Thus, we decided to add a local time of 09:00, then converted in UTC.

```{r ctd_hydro, echo=TRUE, warning = FALSE, message = FALSE}
dat <-  read_delim("http://www.obs-vlfr.fr/data/files/~radehydro/radehydro_ctd.csv.gz", delim = ",", col_names = TRUE, col_types = cols(id = "c", date = "D", date_time = "T", fluo_calib = "d", fluorescence="d", oxygen_mll="d", oxygen_sat="d", oxygen_umolkg="d", par="d", v0="d", v2="d", v3="d"), na = c("NA")) %>%
    dplyr::select(-date_time) %>%
#  dplyr::mutate(date = dmy(date)) %>%
  # eliminate duplicate rows
  #dplyr::filter(id != "b18233_01_sbe25plus - Copie"	& id != "b18233_sbe25plus - Copie") %>%
    dplyr::rename(depth = pressure)

start_ts <- dat %>% # beginning of time series
  dplyr::group_by(station) %>% 
  dplyr::summarise(min = min(date))

knitr::kable(start_ts, caption = "Starting dates of time series", col.names = c("Station", "Starting date"))

# eliminate B data when B+ starts except on 2019-08-07 when B+ profile is not available
z <- dat %>% 
  dplyr::mutate(station = factor(station)) %>% # station as factor
  dplyr::filter(station %in% c('B', 'B+')) %>% # only keep Point B and B+
  dplyr::filter(station == 'B+' | (station == 'B' & date < "2004-12-21") | (station == 'B' & date == "2019-08-06")) 

# add extra profiles of 2018
# See Profiles_sonde_supplémentaires_aout_2018_point B Samir.xlsx

supp1 <- read_excel(paste0(path,"data/radehydro_ctd/", "Profiles_sonde_supplementaires_aout_2018_pointB_Samir.xlsx"), sheet = 1) %>% 
  select(station, date, depth = PrdM, temperature = Potemp090C, salinity = Sal00) %>%
  mutate(date = ymd(date))
supp2 <- read_excel(paste0(path,"data/radehydro_ctd/", "Profiles_sonde_supplementaires_aout_2018_pointB_Samir.xlsx"), sheet = 2) %>% 
  mutate(date = ymd(date))
  supp <- bind_rows(supp1, supp2)
dat <- bind_rows(dat, supp) %>%
  arrange(date)
```

```{r ctd_hydro 1m, echo=TRUE, warning = FALSE, message = FALSE, out.width='100%'}
# select surface (1 m to 3 m) for B or B+ data
# B
rh_B_1m <- dat %>%
  dplyr::select(station, date , depth, salinity, temperature, oxygen_mll, oxygen_umolkg) %>%
  dplyr::filter( (depth >= 1 & depth <= 3))%>%
  dplyr::filter( station == "B")

rh_B_1m_mean <- rh_B_1m %>%
  dplyr::group_by(date) %>%
  dplyr::summarise(mean_sal_rhB = mean(salinity, na.rm=TRUE),
                   mean_temp_rhB = mean(temperature, na.rm=TRUE),
                   mean_oxy_mll_rhB = mean(oxygen_mll, na.rm=TRUE),
                   mean_oxy_umolkg_rhB = mean(oxygen_umolkg, na.rm=TRUE))
# B+
rh_Bplus_1m <- dat %>%
  dplyr::select(station, date , depth, salinity, temperature, oxygen_mll, oxygen_umolkg) %>%
  dplyr::filter( (depth >= 1 & depth <= 3))%>%
  dplyr::filter( station == "B+")

rh_Bplus_1m_mean <- rh_Bplus_1m %>%
  dplyr::group_by(date) %>%
  dplyr::summarise(mean_sal_rhBplus = mean(salinity, na.rm=TRUE),
                   mean_temp_rhBplus = mean(temperature, na.rm=TRUE),
                   mean_oxy_mll_rhBplus = mean(oxygen_mll, na.rm=TRUE),
                   mean_oxy_umolkg_rhBplus = mean(oxygen_umolkg, na.rm=TRUE))

# bind the 2 df (B and B+)
rh_B_Bplus_1m_mean <- full_join(rh_B_1m_mean, rh_Bplus_1m_mean, by=NULL)
rh_B_Bplus_1m_mean$date <- as.POSIXct(rh_B_Bplus_1m_mean$date)

# put 09:00:00 as time (local time)
rh_B_Bplus_1m_mean <- rh_B_Bplus_1m_mean %>%
  dplyr::mutate(time = " 09:00:00") %>%
  dplyr::mutate(datetime = paste0(date, time)) 
rh_B_Bplus_1m_mean$datetime <- ymd_hms(rh_B_Bplus_1m_mean$datetime, tz="Europe/Paris")

# convert local time to UTC time
rh_B_Bplus_1m_mean$datetime <- with_tz(rh_B_Bplus_1m_mean$datetime, "UTC")
```

```{r ctd_hydro 50m, echo=TRUE, warning = FALSE, message = FALSE, out.width='100%'}
# select deep (49 m to 51 m) for B or B+ data
# B
rh_B_50m <- dat %>%
  dplyr::select(station, date , depth, salinity, temperature, oxygen_mll, oxygen_umolkg) %>%
  dplyr::filter( (depth >= 49 & depth <= 51))%>%
  dplyr::filter( station == "B")

rh_B_50m_mean <- rh_B_50m %>%
  dplyr::group_by(date) %>%
  dplyr::summarise(mean_sal_rhB = mean(salinity, na.rm=TRUE),
                   mean_temp_rhB = mean(temperature, na.rm=TRUE),
                   mean_oxy_mll_rhB = mean(oxygen_mll, na.rm=TRUE),
                   mean_oxy_umolkg_rhB = mean(oxygen_umolkg, na.rm=TRUE))
# B+
rh_Bplus_50m <- dat %>%
  dplyr::select(station, date , depth, salinity, temperature, oxygen_mll, oxygen_umolkg) %>%
  dplyr::filter( (depth >= 49 & depth <= 51))%>%
  dplyr::filter( station == "B+")

rh_Bplus_50m_mean <- rh_Bplus_50m %>%
  dplyr::group_by(date) %>%
  dplyr::summarise(mean_sal_rhBplus = mean(salinity, na.rm=TRUE),
                   mean_temp_rhBplus = mean(temperature, na.rm=TRUE),
                   mean_oxy_mll_rhBplus = mean(oxygen_mll, na.rm=TRUE),
                   mean_oxy_umolkg_rhBplus = mean(oxygen_umolkg, na.rm=TRUE))
# bind the 2 df (B and B+)
rh_B_Bplus_50m_mean <- full_join(rh_B_50m_mean, rh_Bplus_50m_mean, by=NULL)
rh_B_Bplus_50m_mean$date <- as.POSIXct(rh_B_Bplus_50m_mean$date)

# put 09:00:00 as time (local time)
rh_B_Bplus_50m_mean <- rh_B_Bplus_50m_mean %>%
  dplyr::mutate(time = " 09:00:00") %>%
  dplyr::mutate(datetime = paste0(date, time)) 
rh_B_Bplus_50m_mean$datetime <- ymd_hms(rh_B_Bplus_50m_mean$datetime, tz="Europe/Paris")

# convert local time to UTC time
rh_B_Bplus_50m_mean$datetime <- with_tz(rh_B_Bplus_50m_mean$datetime, "UTC")

```

## **Temperature**

### **1 m**

```{r plot ctd_hydro 1m Temp, echo=TRUE, warning = FALSE, message = FALSE, out.width='100%'}
## Temp 1m
rh_temp_xts <- dplyr::select(rh_B_Bplus_1m_mean, date, mean_temp_rhBplus, mean_temp_rhB)
rh_temp_xts <- as.xts(rh_temp_xts, order.by=rh_temp_xts$date)

dygraph(rh_temp_xts,  main = "Temperature 1m Rade Hydro: B / B+", ylab = "") %>%
    dySeries("mean_temp_rhB", drawPoints = TRUE, pointSize=4, label = "Temp B", color ="blue") %>%
   dySeries("mean_temp_rhBplus", drawPoints = TRUE, pointSize=2, label = "Temp B+", color="red")%>%
 # dyLegend(show = "always", width = 600)%>%
  #dyAxis("y",valueRange = c(-0.1, 0.11))%>%
dyOptions(
    drawGrid = TRUE,
    drawPoints = TRUE,
    useDataTimezone = TRUE)%>%
  dyRangeSelector(height = 30)

# Property plot
titre <- "Temperature 1m Rade Hydro: B vs B+"
fit <- lmodel2(data = rh_B_Bplus_1m_mean, mean_temp_rhBplus ~ mean_temp_rhB, nperm = 99)
p_rh_temp <-  ggreg2(fit, "mean_temp_rhB", "mean_temp_rhBplus") +
  geom_abline(aes(intercept = 0, slope = 1), linetype = 2) +
  mytheme+labs(x="Temp Point B", y="Temp Point B+")
print(p_rh_temp)
```

### **50 m**

```{r plot ctd_hydro 50m Temp, echo=TRUE, warning = FALSE, message = FALSE, out.width='100%'}
## Temp 50m
rh_temp_xts <- dplyr::select(rh_B_Bplus_50m_mean, date, mean_temp_rhBplus, mean_temp_rhB)
rh_temp_xts <- as.xts(rh_temp_xts, order.by=rh_temp_xts$date)

dygraph(rh_temp_xts,  main = "Temperature 50m Rade Hydro: B / B+", ylab = "") %>%
    dySeries("mean_temp_rhB", drawPoints = TRUE, pointSize=4, label = "Temp B", color ="blue") %>%
   dySeries("mean_temp_rhBplus", drawPoints = TRUE, pointSize=2, label = "Temp B+", color="red")%>%
 # dyLegend(show = "always", width = 600)%>%
  #dyAxis("y",valueRange = c(-0.1, 0.11))%>%
dyOptions(
    drawGrid = TRUE,
    drawPoints = TRUE,
    useDataTimezone = TRUE)%>%
  dyRangeSelector(height = 30)
# Property plot
titre <- "Temperature 50m Rade Hydro: B vs B+"
fit <- lmodel2(data = rh_B_Bplus_50m_mean, mean_temp_rhBplus ~ mean_temp_rhB, nperm = 99)
p_rh_temp <-  ggreg2(fit, "mean_temp_rhB", "mean_temp_rhBplus") +
  geom_abline(aes(intercept = 0, slope = 1), linetype = 2) +
  mytheme+labs(x="Temp Point B", y="Temp Point B+")
print(p_rh_temp)
```

## **Salinity**

### **1 m**
```{r plot ctd_hydro 1m Sal, echo=TRUE, warning = FALSE, message = FALSE, out.width='100%'}
## Sal 1m
rh_sal_xts <- dplyr::select(rh_B_Bplus_1m_mean, date, mean_sal_rhBplus, mean_sal_rhB)
rh_sal_xts <- as.xts(rh_sal_xts, order.by=rh_sal_xts$date)

dygraph(rh_sal_xts,  main = "Salinity 1m Rade Hydro: B / B+", ylab = "") %>%
    dySeries("mean_sal_rhB", drawPoints = TRUE, pointSize=4, label = "Sal B", color ="blue") %>%
   dySeries("mean_sal_rhBplus", drawPoints = TRUE, pointSize=2, label = "Sal B+", color="red")%>%
 # dyLegend(show = "always", width = 600)%>%
  #dyAxis("y",valueRange = c(-0.1, 0.11))%>%
dyOptions(
    drawGrid = TRUE,
    drawPoints = TRUE,
    useDataTimezone = TRUE)%>%
  dyRangeSelector(height = 30)

# Property plot
titre <- "Salinity 1m Rade Hydro: B vs B+"
fit <- lmodel2(data = rh_B_Bplus_1m_mean, mean_sal_rhBplus ~ mean_sal_rhB, nperm = 99)
p_rh_sal <-  ggreg2(fit, "mean_sal_rhB", "mean_sal_rhBplus") +
  geom_abline(aes(intercept = 0, slope = 1), linetype = 2) +
  mytheme+labs(x="Sal Point B", y="Sal Point B+")
print(p_rh_sal)

```

### **50 m**

```{r plot ctd_hydro 50m Sal, echo=TRUE, warning = FALSE, message = FALSE, out.width='100%'}
## Sal
rh_sal_xts <- dplyr::select(rh_B_Bplus_50m_mean, date, mean_sal_rhBplus, mean_sal_rhB)
rh_sal_xts <- as.xts(rh_sal_xts, order.by=rh_sal_xts$date)

dygraph(rh_sal_xts,  main = "Salinity 50m Rade Hydro: B / B+", ylab = "") %>%
    dySeries("mean_sal_rhB", drawPoints = TRUE, pointSize=4, label = "Sal B", color ="blue") %>%
   dySeries("mean_sal_rhBplus", drawPoints = TRUE, pointSize=2, label = "Sal B+", color="red")%>%
 # dyLegend(show = "always", width = 600)%>%
  #dyAxis("y",valueRange = c(-0.1, 0.11))%>%
dyOptions(
    drawGrid = TRUE,
    drawPoints = TRUE,
    useDataTimezone = TRUE)%>%
  dyRangeSelector(height = 30)

# Property plot
titre <- "Salinity 50m Rade Hydro: B vs B+"
fit <- lmodel2(data = rh_B_Bplus_50m_mean, mean_sal_rhBplus ~ mean_sal_rhB, nperm = 99)
p_rh_sal <-  ggreg2(fit, "mean_sal_rhB", "mean_sal_rhBplus") +
  geom_abline(aes(intercept = 0, slope = 1), linetype = 2) +
  mytheme+labs(x="Sal Point B", y="Sal Point B+")
print(p_rh_sal)
```

## **Oxygen**

### **1 m**

```{r plot ctd_hydro 1m Oxy, echo=TRUE, warning = FALSE, message = FALSE, out.width='100%'}
## Oxy umolkg 1m
rh_oxymll_xts <- dplyr::select(rh_B_Bplus_1m_mean, date, mean_oxy_mll_rhBplus, mean_oxy_mll_rhB)
rh_oxymll_xts <- as.xts(rh_oxymll_xts, order.by=rh_oxymll_xts$date)

dygraph(rh_oxymll_xts,  main = "Oxygen (ml/l) 1m Rade Hydro: B / B+", ylab = "") %>%
    dySeries("mean_oxy_mll_rhB", drawPoints = TRUE, pointSize=4, label = "Oxy_mll B", color ="red") %>%
   dySeries("mean_oxy_mll_rhBplus", drawPoints = TRUE, pointSize=3, label = "Oxy_mll B+", color="blue")%>%
 # dyLegend(show = "always", width = 600)%>%
  #dyAxis("y",valueRange = c(-0.1, 0.11))%>%
dyOptions(
    drawGrid = TRUE,
    drawPoints = TRUE,
    useDataTimezone = TRUE)%>%
  dyRangeSelector(height = 30)

# Property plot
titre <- "Oxygen (ml/l) 1m Rade Hydro: B vs B+"
fit <- lmodel2(data = rh_B_Bplus_1m_mean, mean_oxy_mll_rhBplus ~ mean_oxy_mll_rhB, nperm = 99)
p_rh_oxy_mll <-  ggreg2(fit, "mean_oxy_mll_rhB", "mean_oxy_mll_rhBplus") +
  geom_abline(aes(intercept = 0, slope = 1), linetype = 2) +
  mytheme+labs(x="Oxy_mll Point B", y="Oxy_mll Point B+")
print(p_rh_oxy_mll)
```

```{r oxy 1m ctd_hydro wink, echo=TRUE, warning = FALSE, message = FALSE, out.width='100%'}
# Reading the Winkler PointB data perweek.
winkler<- tbl_df(
  read_delim(file=paste0(path,"/data/data_ptb_winkler.txt"), 
delim = "\t", 
col_names = TRUE,# col_types = typ,
na = c("NA", "999999.00")) %>%
dplyr::rename(date = DATE, 
              ptb_oxy_wink= "O (Oxygène)")) 
winkler$date <- as.POSIXct(winkler$date)
winkler$ptb_oxy_wink <- as.numeric(as.character(winkler$ptb_oxy_wink))

# Select 1m ptb_oxy_wink data 
wink_1m <- winkler %>%
  dplyr::group_by(date) %>%
  dplyr::select(date,ptb_oxy_wink,qO, PROF_TEXT )%>%
   dplyr::filter(PROF_TEXT == "S" & ptb_oxy_wink < 20 )%>%
  dplyr::filter(qO == 2  |qO == 6)
# put 09:00:00 as time (local time)
wink_1m <- wink_1m %>%
  dplyr::mutate(time = " 09:00:00") %>%
  dplyr::mutate(datetime = paste0(date, time)) 
wink_1m$datetime <- ymd_hms(wink_1m$datetime, tz="Europe/Paris")

# convert local time to UTC time
wink_1m$datetime <- with_tz(wink_1m$datetime, "UTC")

# Adding the Winkler PointB 1m data perweek to rh_B_Bplus_1m_mean
#put wink_1m as data.table
wink_1m <- as.data.table(wink_1m)
rh_B_Bplus_1m_mean <- as.data.table(rh_B_Bplus_1m_mean)
# set datetime column as key column, easy to bind
setkey( wink_1m, datetime )
setkey(rh_B_Bplus_1m_mean, datetime)
# combine
combined_1_B_Bplus_wink <- rh_B_Bplus_1m_mean[wink_1m, roll = "nearest" ]

###
# PLOT all oxygen data as time series
ptb_wink_ctd_xts <- dplyr::select(combined_1_B_Bplus_wink, datetime, mean_oxy_mll_rhBplus, ptb_oxy_wink)
ptb_wink_ctd_xts <- as.xts(ptb_wink_ctd_xts, order.by=ptb_wink_ctd_xts$datetime)

dygraph(ptb_wink_ctd_xts,  main = "Oxygen (ml/l) 1m: PTB+ + Winkler", ylab = "") %>%
dySeries("mean_oxy_mll_rhBplus", drawPoints = TRUE, pointSize=4, label = "Oxy PTB+", color ="blue") %>%
dySeries("ptb_oxy_wink", drawPoints = TRUE, pointSize=3, label = "Oxy winkler PTB", color ="green")%>%
 # dyLegend(show = "always", width = 600)%>%
  #dyAxis("y",valueRange = c(-0.1, 0.11))%>%
dyOptions(
    drawGrid = TRUE,
    drawPoints = TRUE,
    useDataTimezone = TRUE)%>%
  dyRangeSelector(height = 30)
###
#delta oxy
combined_1_B_Bplus_wink <- combined_1_B_Bplus_wink %>% 
  dplyr::mutate(oxy_mll_rhBplus_wink_detla = mean_oxy_mll_rhBplus - ptb_oxy_wink, 
                oxy_mll_rhB_wink_detla = mean_oxy_mll_rhB - ptb_oxy_wink)
#plot
oxy_rhBplus_wink_xts <- dplyr::select(combined_1_B_Bplus_wink,datetime, oxy_mll_rhBplus_wink_detla)
oxy_rhBplus_wink_xts <- as.xts(oxy_rhBplus_wink_xts, order.by=oxy_rhBplus_wink_xts$datetime)

dygraph(oxy_rhBplus_wink_xts,  main = "Delta Oxy ptB+ Winkler 1m", ylab = "") %>%
     dySeries("oxy_mll_rhBplus_wink_detla", drawPoints = TRUE, pointSize=2, label = "delta (ml/l)", color="black")%>%
   dyLimit(0,strokePattern = "dashed", color = "black") %>% 
 # dyLegend(show = "always", width = 600)%>%
  #dyAxis("y",valueRange = c(-0.1, 0.11))%>%
dyOptions(
    drawGrid = TRUE,
    drawPoints = TRUE,
    useDataTimezone = TRUE)%>%
  dyRangeSelector(height = 30)
###
titre <- "Oxygen 1m: Point B+ CTD vs Point B Winkler"
fit <- lmodel2(data = combined_1_B_Bplus_wink, ptb_oxy_wink ~ mean_oxy_mll_rhBplus, nperm = 99)
p_Oxyptbwink_Oxyptb <-  ggreg2(fit, "mean_oxy_mll_rhBplus", "ptb_oxy_wink") +
  geom_abline(aes(slope= 1, intercept =0), linetype = 2) +
  mytheme+labs(x="Oxy Point B+ CTD", y="Oxy Point B Winkler")
print(p_Oxyptbwink_Oxyptb)
```

### **50 m**

```{r plot ctd_hydro 50m Oxy, echo=TRUE, warning = FALSE, message = FALSE, out.width='100%'}
## Oxy umolkg 50m
rh_oxymll_xts <- dplyr::select(rh_B_Bplus_50m_mean, date, mean_oxy_mll_rhBplus, mean_oxy_mll_rhB)
rh_oxymll_xts <- as.xts(rh_oxymll_xts, order.by=rh_oxymll_xts$date)

dygraph(rh_oxymll_xts,  main = "Oxygen (ml/l 50m Rade Hydro: B / B+", ylab = "") %>%
  dySeries("mean_oxy_mll_rhB", drawPoints = TRUE, pointSize=4, label = "Oxy_mll B", color ="blue") %>%
  dySeries("mean_oxy_mll_rhBplus", drawPoints = TRUE, pointSize=2, label = "Oxy_mll B+", color="red")%>%
 # dyLegend(show = "always", width = 600)%>%
  #dyAxis("y",valueRange = c(-0.1, 0.11))%>%
dyOptions(
    drawGrid = TRUE,
    drawPoints = TRUE,
    useDataTimezone = TRUE)%>%
  dyRangeSelector(height = 30)

# Property plot
titre <- "Oxygen (ml/l) 50m Rade Hydro: B vs B+"
fit <- lmodel2(data = rh_B_Bplus_50m_mean, mean_oxy_mll_rhBplus ~ mean_oxy_mll_rhB, nperm = 99)
p_rh_oxy_mll <-  ggreg2(fit, "mean_oxy_mll_rhB", "mean_oxy_mll_rhBplus") +
  geom_abline(aes(intercept = 0, slope = 1), linetype = 2) +
  mytheme+labs(x="Oxy_mll Point B", y="Oxy_mll Point B+")
print(p_rh_oxy_mll)
```

```{r  oxy 50m ctd_hydro wink, echo=TRUE, warning = FALSE, message = FALSE, out.width='100%'}
# Select 50m ptb_oxy_wink data 
wink_50m <- winkler %>%
  dplyr::group_by(date) %>%
  dplyr::select(date,ptb_oxy_wink,qO, PROF_TEXT )%>%
   dplyr::filter(PROF_TEXT == "F"& ptb_oxy_wink < 20)%>%
  dplyr::filter(qO == 2  |qO == 6)
# put 09:00:00 as time (local time)
wink_50m <- wink_50m %>%
  dplyr::mutate(time = " 09:00:00") %>%
  dplyr::mutate(datetime = paste0(date, time)) 
wink_50m$datetime <- ymd_hms(wink_50m$datetime, tz="Europe/Paris")
# convert local time to UTC time
wink_50m$datetime <- with_tz(wink_50m$datetime, "UTC")
####

# Adding the Winkler PointB 50m data perweek to rh_B_Bplus_50m_mean
#put data as data.table
wink_50m <- as.data.table(wink_50m)
rh_B_Bplus_50m_mean<- as.data.table(rh_B_Bplus_50m_mean)
# set datetime column as key column, easy to bind
setkey(wink_50m, datetime)
setkey(rh_B_Bplus_50m_mean, datetime)
# combine
combined_50_B_Bplus_wink <- rh_B_Bplus_50m_mean[wink_50m, roll = "nearest" ]

###
# PLOT all oxygen data as time series
ptb_wink_ctd_xts <- dplyr::select(combined_50_B_Bplus_wink, datetime, mean_oxy_mll_rhBplus, ptb_oxy_wink)
ptb_wink_ctd_xts <- as.xts(ptb_wink_ctd_xts, order.by=ptb_wink_ctd_xts$datetime)

dygraph(ptb_wink_ctd_xts,  main = "Oxygen (ml/l) 50m: PTB+ + Winkler", ylab = "") %>%
dySeries("mean_oxy_mll_rhBplus", drawPoints = TRUE, pointSize=4, label = "Oxy PTB+", color ="blue") %>%
dySeries("ptb_oxy_wink", drawPoints = TRUE, pointSize=3, label = "Oxy winkler PTB", color ="green")%>%
 # dyLegend(show = "always", width = 600)%>%
  #dyAxis("y",valueRange = c(-0.1, 0.11))%>%
dyOptions(
    drawGrid = TRUE,
    drawPoints = TRUE,
    useDataTimezone = TRUE)%>%
  dyRangeSelector(height = 30)
###
#delta oxy
combined_50_B_Bplus_wink <- combined_50_B_Bplus_wink %>% 
  dplyr::mutate(oxy_mll_rhBplus_wink_detla = mean_oxy_mll_rhBplus - ptb_oxy_wink, 
                oxy_mll_rhB_wink_detla = mean_oxy_mll_rhB - ptb_oxy_wink)
#plot
oxy_rhBplus_wink_xts <- dplyr::select(combined_50_B_Bplus_wink,datetime, oxy_mll_rhBplus_wink_detla)
oxy_rhBplus_wink_xts <- as.xts(oxy_rhBplus_wink_xts, order.by=oxy_rhBplus_wink_xts$datetime)

dygraph(oxy_rhBplus_wink_xts,  main = "Delta Oxy ptB+ Winkler 50m", ylab = "") %>%
     dySeries("oxy_mll_rhBplus_wink_detla", drawPoints = TRUE, pointSize=2, label = "delta Oxy ml/l", color="black")%>%
   dyLimit(0,strokePattern = "dashed", color = "black") %>% 
 # dyLegend(show = "always", width = 600)%>%
  #dyAxis("y",valueRange = c(-0.1, 0.11))%>%
dyOptions(
    drawGrid = TRUE,
    drawPoints = TRUE,
    useDataTimezone = TRUE)%>%
  dyRangeSelector(height = 30)
###
titre <- "Oxygen 50m: Point B+ CTD vs Point B Winkler"
fit <- lmodel2(data = combined_50_B_Bplus_wink, ptb_oxy_wink ~ mean_oxy_mll_rhBplus, nperm = 99)
p_Oxyptbwink_Oxyptb <-  ggreg2(fit, "mean_oxy_mll_rhBplus", "ptb_oxy_wink") +
  geom_abline(aes(slope= 1, intercept =0), linetype = 2) +
  mytheme+labs(x="Oxy Point B+ CTD", y="Oxy Point B Winkler")
print(p_Oxyptbwink_Oxyptb)
```

# **Comparison EOL - SOMLIT (Point B)**  {.tabset .tabset-pills}

In this section, T, S and Oxy are compared between EOL and SOMLIT data. 

- SOMLIT data are filtered in the "Rade hydro, SOMLIT" section above. Data from B+ station (not B) and from 1 m to 3 m were selected. Gaps in B+ data were filled up with B data.
Time was not available at the beginning. We decided to add 09:00:00 as a local time. It was convert to UTC time in order to make the comparison with EOL data.

## **Temperature** 

### **1 m**

```{r eol pointb 1m Temp, echo=TRUE, warning = FALSE, message = FALSE, out.width='100%'}
#combiine the 2 data frame by nearest time with package data.table
#put rh_B_Bplus_1m_mean as data.table
rh_B_Bplus_1m_mean <- as.data.table(rh_B_Bplus_1m_mean)
eol <- as.data.table(eol)
# set datetime column as key column, easy to bind
setkey( eol, datetime )
setkey( rh_B_Bplus_1m_mean, datetime)
# combine
combined1 <- eol[ rh_B_Bplus_1m_mean, roll = "nearest" ]

# set a datetime column for eol
combined1 <- dplyr::mutate(combined1, datetime_eol=str_c(Date, " ", Heure) %>% parse_datetime(format="%Y%m%d %H%M%S"))
#calcul the difference between time and keep only closest time <6 hours.
combined1 <- dplyr::mutate(combined1,delta_datetime = abs(difftime(datetime, datetime_eol, units="hours")))
#keep only <6 hours
combined1 <-  combined1    %>%    
 dplyr::filter(delta_datetime <= 6)
###
#Fill ptB+ gaps with ptB data
combined1 <- combined1 %>% 
  dplyr::mutate(mean_temp_rhBplus = ifelse(is.na(mean_temp_rhBplus), mean_temp_rhB, mean_temp_rhBplus),
                mean_sal_rhBplus = ifelse(is.na(mean_sal_rhBplus), mean_sal_rhB, mean_sal_rhBplus),
                mean_oxy_mll_rhBplus = ifelse(is.na(mean_oxy_mll_rhBplus), mean_oxy_mll_rhB, mean_oxy_mll_rhBplus),
                mean_oxy_umolkg_rhBplus = ifelse(is.na(mean_oxy_umolkg_rhBplus), mean_oxy_umolkg_rhB, mean_oxy_umolkg_rhBplus))
###

#eol_ptb_1m
eol_ptb_temp_xts <- dplyr::select(combined1, datetime, mean_temp_rhBplus, temp_eol)
eol_ptb_temp_xts <- as.xts(eol_ptb_temp_xts, order.by=combined_1_B_Bplus_wink_eol$datetime)

dygraph(eol_ptb_temp_xts,  main = "Temperature 1m: EOL - PTB", ylab = "") %>%
dySeries("temp_eol", drawPoints = TRUE, pointSize=4, label = "Temp EOL", color ="red")%>%
  dySeries("mean_temp_rhBplus", drawPoints = TRUE, pointSize=4, label = "Temp PTB+", color ="blue") %>%

 # dyLegend(show = "always", width = 600)%>%
 #dyAxis("y",valueRange = c(-0.1, 0.11))%>%
dyOptions(
    drawGrid = TRUE,
    drawPoints = TRUE,
    useDataTimezone = TRUE)%>%
  dyRangeSelector(height = 30)

###
titre <- "Temperature 1m: EOL vs Point B+"
fit <- lmodel2(data = combined1, mean_temp_rhBplus ~ temp_eol, nperm = 99)
p_Tptb_Teol <-  ggreg2(fit, "temp_eol", "mean_temp_rhBplus") +
  geom_abline(aes(slope= 1, intercept =0), linetype = 2) +
  mytheme+labs(x="T EOL", y="T Point B+")

print(p_Tptb_Teol)
```

## **Salinity**

### **1 m**

```{r eol pointb comp Sal, echo=TRUE, message=FALSE, warning=FALSE, out.width='100%'}

eol_ptb_sal_xts <- dplyr::select(combined1, datetime, mean_sal_rhBplus, sal_eol)
eol_ptb_sal_xts <- as.xts(eol_ptb_sal_xts, order.by=eol_ptb_sal_xts$datetime)

dygraph(eol_ptb_sal_xts,  main = "Salinity comparaison: EOL - ptB+", ylab = "") %>%
    dySeries("mean_sal_rhBplus", drawPoints = TRUE, pointSize=4, label = "Sal ptB+", color ="blue") %>%
dySeries("sal_eol", drawPoints = TRUE, pointSize=2, label = "Sal EOL", color ="red")%>%
 # dyLegend(show = "always", width = 600)%>%
  #dyAxis("y",valueRange = c(-0.1, 0.11))%>%
dyOptions(
    drawGrid = TRUE,
    drawPoints = TRUE,
    useDataTimezone = TRUE)%>%
  dyRangeSelector(height = 30)

#delta sal
combined1 <- combined1 %>% 
  dplyr::mutate(sal_eol_rhBplus_detla = mean_sal_rhBplus - sal_eol)
#plot
oxy_eol_wink_xts <- dplyr::select(combined1,datetime, sal_eol_rhBplus_detla)
oxy_eol_wink_xts <- as.xts(oxy_eol_wink_xts, order.by=oxy_eol_wink_xts$datetime)

dygraph(oxy_eol_wink_xts,  main = "Delta Sal EOL / ptB+ 1m", ylab = "") %>%
     dySeries("sal_eol_rhBplus_detla", drawPoints = TRUE, pointSize=2, label = "delta (PSU)", color="black")%>%
   dyLimit(0,strokePattern = "dashed", color = "black") %>% 
 # dyLegend(show = "always", width = 600)%>%
  #dyAxis("y",valueRange = c(-0.1, 0.11))%>%
dyOptions(
    drawGrid = TRUE,
    drawPoints = TRUE,
    useDataTimezone = TRUE)%>%
  dyRangeSelector(height = 30)

###
titre <- "Salinity: EOL vs ptB+ 1m"
fit <- lmodel2(data = combined1, mean_sal_rhBplus ~ sal_eol, nperm = 99)
p_Sptb_Seol <-  ggreg2(fit, "sal_eol", "mean_sal_rhBplus") +
  geom_abline(aes(slope= 1, intercept =0), linetype = 2) +
  mytheme+labs(x="Sal EOL", y="Sal Point B+")

print(p_Sptb_Seol)
```

## **Oxygen**

###  **1 m**

```{r eol pointb Oxy 1m, echo=TRUE, warning = FALSE, message = FALSE, out.width='100%'}
# Reading the combined ptb + Winkler dataframe created before = combined_1_B_Bplus_wink.
#put wink_1m as data.table
combined_1_B_Bplus_wink <- as.data.table(combined_1_B_Bplus_wink)
# set datetime column as key column, easy to bind
setkey( combined_1_B_Bplus_wink, datetime )
# combine to eol
combined_1_B_Bplus_wink_eol <- eol[ combined_1_B_Bplus_wink, roll = "nearest" ]
# set a datetime column for eol
combined_1_B_Bplus_wink_eol <- dplyr::mutate(combined_1_B_Bplus_wink_eol, datetime_eol=str_c(Date, " ", Heure) %>% parse_datetime(format="%Y%m%d %H%M%S"))
#calculate the difference between time and keep only closest time <6 hours.
combined_1_B_Bplus_wink_eol <- dplyr::mutate(combined_1_B_Bplus_wink_eol,delta_datetime = abs(difftime(datetime, datetime_eol, units="hours")))
#keep only <6 hours
combined_1_B_Bplus_wink_eol <-  combined_1_B_Bplus_wink_eol    %>%    
 dplyr::filter(delta_datetime <= 6)

###
# PLOT all oxygen data as time series
eol_ptb_oxy_xts <- dplyr::select(combined_1_B_Bplus_wink_eol, datetime, mean_oxy_mll_rhBplus, oxy_eol, ptb_oxy_wink)
eol_ptb_oxy_xts <- as.xts(eol_ptb_oxy_xts, order.by=eol_ptb_oxy_xts$datetime)

dygraph(eol_ptb_oxy_xts,  main = "Oxygen (ml/l) 1m: EOL - ptB+ - Winkler ptB)", ylab = "") %>%
dySeries("mean_oxy_mll_rhBplus", drawPoints = TRUE, pointSize=4, label = "Oxy ptB+", color ="blue") %>%
dySeries("oxy_eol", drawPoints = TRUE, pointSize=2, label = "Oxy EOL", color ="red")%>%
dySeries("ptb_oxy_wink", drawPoints = TRUE, pointSize=2, label = "Oxy winkler PTB", color ="green")%>%
 # dyLegend(show = "always", width = 600)%>%
  #dyAxis("y",valueRange = c(-0.1, 0.11))%>%
dyOptions(connectSeparatedPoints = TRUE,
    drawGrid = TRUE,
    drawPoints = TRUE,
    useDataTimezone = TRUE)%>%
  dyRangeSelector(height = 30)

###
#delta oxy
combined_1_B_Bplus_wink_eol <- combined_1_B_Bplus_wink_eol %>% 
  dplyr::mutate(oxy_mll_Bplus_wink_detla = oxy_eol - mean_oxy_mll_rhBplus,
                oxy_mll_eol_wink_detla = oxy_eol - ptb_oxy_wink)
#plot
oxy_eol_wink_xts <- dplyr::select(combined_1_B_Bplus_wink_eol,datetime, oxy_mll_eol_wink_detla)
oxy_eol_wink_xts <- as.xts(oxy_eol_wink_xts, order.by=oxy_eol_wink_xts$datetime)

dygraph(oxy_eol_wink_xts,  main = "Delta Oxy EOL / Winkler 1m", ylab = "") %>%
     dySeries("oxy_mll_eol_wink_detla", drawPoints = TRUE, pointSize=2, label = "delta (ml/l)", color="black")%>%
   dyLimit(0,strokePattern = "dashed", color = "black") %>% 
 # dyLegend(show = "always", width = 600)%>%
  #dyAxis("y",valueRange = c(-0.1, 0.11))%>%
dyOptions(
    drawGrid = TRUE,
    drawPoints = TRUE,
    useDataTimezone = TRUE)%>%
  dyRangeSelector(height = 30)
###
#plot
oxy_eol_wink_xts <- dplyr::select(combined_1_B_Bplus_wink_eol,datetime, oxy_mll_Bplus_wink_detla)
oxy_eol_wink_xts <- as.xts(oxy_eol_wink_xts, order.by=oxy_eol_wink_xts$datetime)

dygraph(oxy_eol_wink_xts,  main = "Delta Oxy EOL / ptB+ 1m", ylab = "") %>%
     dySeries("oxy_mll_Bplus_wink_detla", drawPoints = TRUE, pointSize=2, label = "delta (ml/l)", color="black")%>%
   dyLimit(0,strokePattern = "dashed", color = "black") %>% 
 # dyLegend(show = "always", width = 600)%>%
  #dyAxis("y",valueRange = c(-0.1, 0.11))%>%
dyOptions(
    drawGrid = TRUE,
    drawPoints = TRUE,
    useDataTimezone = TRUE)%>%
  dyRangeSelector(height = 30)

titre <- "Oxygen 1m: EOL vs Point B+ CTD"
fit <- lmodel2(data = combined_1_B_Bplus_wink_eol, mean_oxy_mll_rhBplus ~ oxy_eol, nperm = 99)
p_Oxyptb_Oxyeol <-  ggreg2(fit, "oxy_eol", "mean_oxy_mll_rhBplus") +
  geom_abline(aes(slope= 1, intercept =0), linetype = 2) +
  mytheme+labs(x="Oxy EOL", y="Oxy Point B+ CTD")
print(p_Oxyptb_Oxyeol)

titre <- "Oxygen 1m: EOL vs Point B Winkler"
fit <- lmodel2(data = combined_1_B_Bplus_wink_eol, ptb_oxy_wink ~ oxy_eol, nperm = 99)
p_Oxyptbwink_Oxyeol <-  ggreg2(fit, "oxy_eol", "ptb_oxy_wink") +
  geom_abline(aes(slope= 1, intercept =0), linetype = 2) +
  mytheme+labs(x="Oxy EOL", y="Oxy Point B Winkler")
print(p_Oxyptbwink_Oxyeol)

titre <- "Oxygen 1m: Point B+ CTD vs Point B Winkler"
fit <- lmodel2(data = combined_1_B_Bplus_wink_eol, ptb_oxy_wink ~ mean_oxy_mll_rhBplus, nperm = 99)
p_Oxyptbwink_Oxyptb <-  ggreg2(fit, "mean_oxy_mll_rhBplus", "ptb_oxy_wink") +
  geom_abline(aes(slope= 1, intercept =0), linetype = 2) +
  mytheme+labs(x="Oxy Point B+ CTD", y="Oxy Point B Winkler")
print(p_Oxyptbwink_Oxyptb)
```

